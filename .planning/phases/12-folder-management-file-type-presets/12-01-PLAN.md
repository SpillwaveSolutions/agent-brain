---
phase: 12-folder-management-file-type-presets
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - agent-brain-server/agent_brain_server/services/folder_manager.py
  - agent-brain-server/agent_brain_server/services/file_type_presets.py
  - agent-brain-server/agent_brain_server/models/folders.py
  - agent-brain-server/agent_brain_server/storage/protocol.py
  - agent-brain-server/agent_brain_server/storage/chroma/backend.py
  - agent-brain-server/agent_brain_server/storage/postgres/backend.py
  - agent-brain-server/tests/test_folder_manager.py
  - agent-brain-server/tests/test_file_type_presets.py
autonomous: true

must_haves:
  truths:
    - "FolderManager persists indexed folder records to JSONL and survives restarts"
    - "FolderManager normalizes all paths via Path.resolve() before storing"
    - "FolderManager uses asyncio.Lock + atomic temp-file-rename for safe writes"
    - "FileTypePresetResolver maps preset names to glob patterns correctly"
    - "Unknown preset names raise ValueError with list of valid presets"
    - "Both ChromaDB and PostgreSQL backends support delete_by_metadata"
  artifacts:
    - path: "agent-brain-server/agent_brain_server/services/folder_manager.py"
      provides: "FolderManager service with JSONL persistence"
      exports: ["FolderManager", "FolderRecord"]
    - path: "agent-brain-server/agent_brain_server/services/file_type_presets.py"
      provides: "File type preset resolution"
      exports: ["FILE_TYPE_PRESETS", "resolve_file_types", "list_presets"]
    - path: "agent-brain-server/agent_brain_server/models/folders.py"
      provides: "Pydantic models for folder API"
      exports: ["FolderInfo", "FolderListResponse", "FolderDeleteRequest", "FolderDeleteResponse"]
    - path: "agent-brain-server/agent_brain_server/storage/protocol.py"
      provides: "Extended protocol with delete_by_metadata"
      contains: "delete_by_metadata"
    - path: "agent-brain-server/agent_brain_server/storage/chroma/backend.py"
      provides: "ChromaDB delete_by_metadata implementation"
      contains: "delete_by_metadata"
    - path: "agent-brain-server/agent_brain_server/storage/postgres/backend.py"
      provides: "PostgreSQL delete_by_metadata implementation"
      contains: "delete_by_metadata"
  key_links:
    - from: "agent-brain-server/agent_brain_server/services/folder_manager.py"
      to: "indexed_folders.jsonl"
      via: "JSONL read/write with atomic rename"
      pattern: "temp_path\\.replace"
    - from: "agent-brain-server/agent_brain_server/storage/chroma/backend.py"
      to: "chromadb collection.delete"
      via: "where filter on source metadata"
      pattern: "delete.*where"
---

<objective>
Create the server-side foundation for folder management and file type presets: the FolderManager service with JSONL persistence, the FileTypePresetResolver pure-function module, Pydantic models for the API layer, and extend StorageBackendProtocol + both backends with delete_by_metadata.

Purpose: These are the building blocks that the API router (Plan 02) and CLI (Plan 03) depend on. Without these, no folder tracking or file type filtering is possible.

Output: 6 new/modified server source files + 2 test files, all passing `task before-push`.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-folder-management-file-type-presets/12-RESEARCH.md

@agent-brain-server/agent_brain_server/storage/protocol.py
@agent-brain-server/agent_brain_server/storage/chroma/backend.py
@agent-brain-server/agent_brain_server/storage/postgres/backend.py
@agent-brain-server/agent_brain_server/models/index.py
@agent-brain-server/agent_brain_server/services/indexing_service.py
@agent-brain-server/agent_brain_server/storage/vector_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FolderManager service with JSONL persistence</name>
  <files>
    agent-brain-server/agent_brain_server/services/folder_manager.py
    agent-brain-server/agent_brain_server/services/__init__.py
    agent-brain-server/tests/test_folder_manager.py
  </files>
  <action>
Create `agent-brain-server/agent_brain_server/services/folder_manager.py` with:

1. **FolderRecord dataclass** with fields:
   - `folder_path: str` (canonical absolute path)
   - `chunk_count: int`
   - `last_indexed: str` (ISO 8601 UTC timestamp string for JSON serialization)
   - `chunk_ids: list[str]` (needed for targeted deletion in FOLD-08)

2. **FolderManager class** with:
   - `__init__(self, state_dir: Path)` — sets `self.jsonl_path = state_dir / "indexed_folders.jsonl"`, creates `asyncio.Lock`, initializes empty `_cache: dict[str, FolderRecord]`
   - `async def initialize(self) -> None` — loads existing JSONL records into `_cache` under lock. Use `asyncio.to_thread(self._load_jsonl)` for non-blocking I/O. Handle missing file gracefully.
   - `async def add_folder(self, folder_path: str, chunk_count: int, chunk_ids: list[str]) -> FolderRecord` — normalize path with `str(Path(folder_path).resolve())`, create FolderRecord with `datetime.now(timezone.utc).isoformat()`, update `_cache`, call `_persist()`. Returns record.
   - `async def remove_folder(self, folder_path: str) -> FolderRecord | None` — normalize path, remove from `_cache`, call `_persist()`. Returns removed record or None.
   - `async def list_folders(self) -> list[FolderRecord]` — return sorted list from `_cache` values (sort by folder_path).
   - `async def get_folder(self, folder_path: str) -> FolderRecord | None` — normalize and look up.
   - `async def _persist(self) -> None` — under lock, write all `_cache` records to temp file, atomic rename via `temp_path.replace(self.jsonl_path)`. Use `asyncio.to_thread(self._write_jsonl)` for non-blocking I/O.
   - `def _load_jsonl(self) -> dict[str, FolderRecord]` — synchronous file read, json.loads per line, return dict keyed by folder_path. Handle empty/corrupt lines with logging warning.
   - `def _write_jsonl(self) -> None` — synchronous write to temp file, rename. Each line is `json.dumps(dataclasses.asdict(record))`.
   - `async def clear(self) -> None` — clear `_cache`, delete JSONL file if exists.

3. **Update `services/__init__.py`** — add FolderManager and FolderRecord exports.

4. **Create tests** at `tests/test_folder_manager.py`:
   - Test initialize with empty dir (no JSONL file)
   - Test initialize with existing JSONL
   - Test add_folder normalizes path (`/foo/../foo/bar` -> resolved)
   - Test add_folder updates existing record (idempotent)
   - Test remove_folder returns record, removes from list
   - Test remove_folder for nonexistent path returns None
   - Test list_folders returns sorted list
   - Test persistence: add folder, create new FolderManager, initialize, verify data survives
   - Test clear removes all records and file
   - Test concurrent adds don't corrupt (use asyncio.gather with multiple adds)
   - Use `tmp_path` fixture for state_dir. All tests async with `@pytest.mark.asyncio`.

Type hints on all functions (mypy strict). Google-style docstrings. Black-formatted (88 chars).
  </action>
  <verify>
cd agent-brain-server && poetry run pytest tests/test_folder_manager.py -v && poetry run mypy agent_brain_server/services/folder_manager.py --strict --ignore-missing-imports
  </verify>
  <done>FolderManager persists folder records to JSONL, normalizes paths, handles concurrent writes safely, and all tests pass with mypy strict.</done>
</task>

<task type="auto">
  <name>Task 2: Create FileTypePresetResolver and Pydantic folder models</name>
  <files>
    agent-brain-server/agent_brain_server/services/file_type_presets.py
    agent-brain-server/agent_brain_server/models/folders.py
    agent-brain-server/agent_brain_server/models/__init__.py
    agent-brain-server/tests/test_file_type_presets.py
  </files>
  <action>
1. **Create `services/file_type_presets.py`** with:

   - `FILE_TYPE_PRESETS: dict[str, list[str]]` constant mapping preset names to glob patterns:
     - `"python"`: `["*.py", "*.pyi", "*.pyw"]`
     - `"javascript"`: `["*.js", "*.jsx", "*.mjs", "*.cjs"]`
     - `"typescript"`: `["*.ts", "*.tsx"]`
     - `"go"`: `["*.go"]`
     - `"rust"`: `["*.rs"]`
     - `"java"`: `["*.java"]`
     - `"csharp"`: `["*.cs"]`
     - `"c"`: `["*.c", "*.h"]`
     - `"cpp"`: `["*.cpp", "*.hpp", "*.cc", "*.hh"]`
     - `"web"`: `["*.html", "*.css", "*.scss", "*.jsx", "*.tsx"]`
     - `"docs"`: `["*.md", "*.txt", "*.rst", "*.pdf"]`
     - `"code"`: union of python + javascript + typescript + go + rust + java + csharp + c + cpp patterns
     - `"text"`: `["*.md", "*.txt", "*.rst"]`
     - `"pdf"`: `["*.pdf"]`

   - `def resolve_file_types(preset_names: list[str]) -> list[str]` — resolve preset names to deduplicated glob patterns. Raise `ValueError` with message `"Unknown file type preset '{name}'. Valid presets: {sorted_list}"` for unknown names.

   - `def list_presets() -> dict[str, list[str]]` — return copy of FILE_TYPE_PRESETS for display.

2. **Create `models/folders.py`** with Pydantic models:

   - `FolderInfo(BaseModel)`:
     - `folder_path: str = Field(..., description="Canonical absolute path")`
     - `chunk_count: int = Field(..., description="Number of indexed chunks")`
     - `last_indexed: str = Field(..., description="ISO 8601 UTC timestamp")`

   - `FolderListResponse(BaseModel)`:
     - `folders: list[FolderInfo]`
     - `total: int`

   - `FolderDeleteRequest(BaseModel)`:
     - `folder_path: str = Field(..., min_length=1, description="Path to folder to remove")`

   - `FolderDeleteResponse(BaseModel)`:
     - `folder_path: str`
     - `chunks_deleted: int`
     - `message: str`

   Add `model_config` with `json_schema_extra` examples on FolderListResponse and FolderDeleteResponse.

3. **Update `models/__init__.py`** — add exports for new folder models.

4. **Create tests** at `tests/test_file_type_presets.py`:
   - Test resolve_file_types with single preset ("python" -> ["*.py", "*.pyi", "*.pyw"])
   - Test resolve_file_types with multiple presets ("python,docs" -> combined, deduplicated)
   - Test resolve_file_types with unknown preset raises ValueError with message listing valid presets
   - Test "code" preset includes patterns from python, javascript, typescript, etc.
   - Test list_presets returns all presets
   - Test resolve_file_types returns deduplicated patterns (no duplicates from overlapping presets)

All with type hints, mypy strict, Black formatting.
  </action>
  <verify>
cd agent-brain-server && poetry run pytest tests/test_file_type_presets.py -v && poetry run mypy agent_brain_server/services/file_type_presets.py agent_brain_server/models/folders.py --strict --ignore-missing-imports
  </verify>
  <done>FileTypePresetResolver resolves all 14 presets correctly, unknown presets raise clear errors, Pydantic models validate, all tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: Extend StorageBackendProtocol + both backends with delete_by_metadata</name>
  <files>
    agent-brain-server/agent_brain_server/storage/protocol.py
    agent-brain-server/agent_brain_server/storage/chroma/backend.py
    agent-brain-server/agent_brain_server/storage/postgres/backend.py
    agent-brain-server/agent_brain_server/storage/vector_store.py
  </files>
  <action>
1. **Extend `storage/protocol.py`** — add `delete_by_metadata` method to `StorageBackendProtocol`:

   ```python
   async def delete_by_metadata(
       self,
       where: dict[str, Any],
   ) -> int:
       """Delete documents matching metadata filter.

       Args:
           where: Metadata filter dict. For ChromaDB uses native where syntax.
                  For PostgreSQL uses metadata JSONB query.

       Returns:
           Number of documents deleted.

       Raises:
           StorageError: If delete operation fails.
       """
       ...
   ```

2. **Implement in `storage/chroma/backend.py`** — add `delete_by_metadata` method to ChromaBackend:
   - First query collection with `where` filter to get matching IDs: use `self.vector_store._collection.get(where=where)` to find matching document IDs
   - CRITICAL GUARD: if resulting `ids` list is empty, return 0 immediately (empty ids=[] delete in ChromaDB wipes entire collection!)
   - Delete by IDs: `await asyncio.to_thread(self.vector_store._collection.delete, ids=matching_ids)`
   - Return count of deleted documents
   - Wrap in try/except -> StorageError(backend="chroma")

3. **Implement in `storage/postgres/backend.py`** — add `delete_by_metadata` method to PostgresBackend:
   - Build SQL: `DELETE FROM documents WHERE metadata @> :filter_json::jsonb RETURNING chunk_id`
   - Use `json.dumps(where)` for the filter parameter
   - Execute via `self.connection_manager` session
   - Return count of deleted rows
   - Wrap in try/except -> StorageError(backend="postgres")

4. **Add helper to `storage/vector_store.py`** — add `delete_by_where` method to VectorStoreManager:
   - `async def delete_by_where(self, where: dict[str, Any]) -> int`
   - Gets matching IDs from collection.get(where=where)
   - Guards against empty IDs
   - Deletes and returns count
   - This is the low-level ChromaDB method that ChromaBackend.delete_by_metadata delegates to

IMPORTANT: The `where` filter for folder deletion uses source path prefix matching. For ChromaDB, the where filter will look like `{"source": {"$contains": "/path/to/folder"}}` or retrieve all and filter by prefix. Since ChromaDB `$contains` is substring match on strings, we can use it for path prefix matching. Alternatively, the FolderManager stores chunk_ids so we can delete by IDs directly — implement both: `delete_by_metadata(where)` for generic use, and the caller (API router in Plan 02) will use stored chunk_ids for precise deletion.

Existing tests in the repo should continue to pass. Run the full test suite to verify no regressions.
  </action>
  <verify>
cd agent-brain-server && poetry run pytest -x -q && poetry run mypy agent_brain_server/storage/protocol.py agent_brain_server/storage/chroma/backend.py agent_brain_server/storage/postgres/backend.py --strict --ignore-missing-imports
  </verify>
  <done>StorageBackendProtocol has delete_by_metadata, both ChromaBackend and PostgresBackend implement it, all existing 686+ tests pass, mypy strict passes.</done>
</task>

</tasks>

<verification>
1. `cd agent-brain-server && poetry run pytest -x -q` — all tests pass (existing + new)
2. `cd agent-brain-server && poetry run mypy agent_brain_server --strict --ignore-missing-imports` — no type errors
3. `cd agent-brain-server && poetry run ruff check agent_brain_server` — no lint errors
4. `cd agent-brain-server && poetry run black --check agent_brain_server` — formatting correct
</verification>

<success_criteria>
- FolderManager persists/loads folder records to/from JSONL with atomic writes
- FileTypePresetResolver maps 14 preset names to correct glob patterns
- Unknown preset names raise ValueError with helpful message
- StorageBackendProtocol.delete_by_metadata exists and both backends implement it
- ChromaDB delete guards against empty IDs (avoids collection wipe)
- All new tests pass, all existing tests pass, mypy strict clean
</success_criteria>

<output>
After completion, create `.planning/phases/12-folder-management-file-type-presets/12-01-SUMMARY.md`
</output>
